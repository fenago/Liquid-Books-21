import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { BookConfig, Chapter } from '@/types';

interface CreateRepoRequest {
  token: string;
  repoName: string;
  bookConfig: BookConfig;
}

export async function POST(request: NextRequest) {
  try {
    const body: CreateRepoRequest = await request.json();
    const { token: providedToken, repoName, bookConfig } = body;

    // Use provided token or fall back to environment variable
    const token = providedToken || process.env.GITHUB_PAT;

    if (!token || !repoName || !bookConfig) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const octokit = new Octokit({ auth: token });

    // Get authenticated user
    const { data: user } = await octokit.users.getAuthenticated();

    // Generate book files
    const files = generateBookFiles(bookConfig);

    // Check if repository already exists
    let repoUrl: string;
    let repoExists = false;

    try {
      const { data: existingRepo } = await octokit.repos.get({
        owner: user.login,
        repo: repoName,
      });
      repoExists = true;
      repoUrl = existingRepo.html_url;
      console.log(`Repository ${repoName} exists, updating...`);
    } catch (e: unknown) {
      const error = e as { status?: number };
      if (error.status !== 404) {
        throw e; // Re-throw if not a 404
      }
      // 404 means repo doesn't exist - we'll create it
    }

    if (repoExists) {
      // UPDATE EXISTING REPO - Push new commit with updated files
      // This avoids the delete+create pattern that triggers abuse detection

      // Get the current HEAD commit on main branch
      const { data: ref } = await octokit.git.getRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
      });
      const baseCommitSha = ref.object.sha;

      // Create a new tree with all files (replaces entire content)
      // Using base_tree: undefined creates a completely new tree (clean slate)
      const { data: tree } = await octokit.git.createTree({
        owner: user.login,
        repo: repoName,
        tree: files.map((file) => ({
          path: file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          content: file.content,
        })),
      });

      // Create a commit with parent
      const { data: commit } = await octokit.git.createCommit({
        owner: user.login,
        repo: repoName,
        message: 'Update book content - Generated by Book Builder',
        tree: tree.sha,
        parents: [baseCommitSha],
      });

      // Update the main branch to point to the new commit
      await octokit.git.updateRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
        sha: commit.sha,
      });

      console.log(`Repository ${repoName} updated with new content`);

    } else {
      // CREATE NEW REPO
      const { data: repo } = await octokit.repos.createForAuthenticatedUser({
        name: repoName,
        description: bookConfig.description,
        auto_init: true,
        private: false,
      });
      repoUrl = repo.html_url;

      // Wait for GitHub to initialize the repository
      await new Promise(resolve => setTimeout(resolve, 1500));

      // Get the SHA of the initial commit on main branch
      const { data: ref } = await octokit.git.getRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
      });
      const baseCommitSha = ref.object.sha;

      // Get the base tree SHA
      const { data: baseCommit } = await octokit.git.getCommit({
        owner: user.login,
        repo: repoName,
        commit_sha: baseCommitSha,
      });
      const baseTreeSha = baseCommit.tree.sha;

      // Create all files in a single commit using Git Data API
      const { data: tree } = await octokit.git.createTree({
        owner: user.login,
        repo: repoName,
        base_tree: baseTreeSha,
        tree: files.map((file) => ({
          path: file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          content: file.content,
        })),
      });

      // Create a commit with parent
      const { data: commit } = await octokit.git.createCommit({
        owner: user.login,
        repo: repoName,
        message: 'Initial book setup - Generated by Book Builder',
        tree: tree.sha,
        parents: [baseCommitSha],
      });

      // Update the main branch to point to the new commit
      await octokit.git.updateRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
        sha: commit.sha,
      });

      console.log(`Repository ${repoName} created with initial content`);
    }

    // Enable GitHub Pages with GitHub Actions workflow
    // Do this ONCE - no retries to save API calls
    // The workflow will trigger automatically on push anyway
    try {
      await octokit.request('POST /repos/{owner}/{repo}/pages', {
        owner: user.login,
        repo: repoName,
        build_type: 'workflow',
        headers: {
          'X-GitHub-Api-Version': '2022-11-28'
        }
      });
      console.log('GitHub Pages enabled');
    } catch (pagesError: unknown) {
      const err = pagesError as { status?: number };
      // 409 = already exists, 422 = validation error - both are fine
      // The push already happened so the workflow will trigger
      console.log('Pages setup status:', err.status);
    }

    return NextResponse.json({
      success: true,
      repoUrl: repoUrl!,
      username: user.login,
      deployedUrl: `https://${user.login}.github.io/${repoName}`,
    });
  } catch (error: unknown) {
    console.error('GitHub API error:', error);

    // Handle rate limiting specifically
    const err = error as { status?: number; message?: string; response?: { headers?: Record<string, string> } };

    if (err.status === 403 && err.message?.includes('rate limit')) {
      // Try to get reset time from headers
      const resetTime = err.response?.headers?.['x-ratelimit-reset'];
      let waitMessage = 'Please wait a few minutes before trying again.';

      if (resetTime) {
        const resetDate = new Date(parseInt(resetTime) * 1000);
        const minutesUntilReset = Math.ceil((resetDate.getTime() - Date.now()) / 60000);
        waitMessage = `Rate limit resets in ${minutesUntilReset} minute${minutesUntilReset !== 1 ? 's' : ''}.`;
      }

      return NextResponse.json(
        {
          error: `GitHub API rate limit exceeded. ${waitMessage}`,
          isRateLimit: true,
          retryAfter: resetTime ? parseInt(resetTime) * 1000 : Date.now() + 60000,
        },
        { status: 429 }
      );
    }

    // Handle other specific errors
    if (err.status === 401) {
      return NextResponse.json(
        { error: 'GitHub token is invalid or expired. Please check your Personal Access Token.' },
        { status: 401 }
      );
    }

    if (err.status === 422) {
      return NextResponse.json(
        { error: 'Invalid repository name or configuration. Please check your inputs.' },
        { status: 422 }
      );
    }

    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'GitHub API failed' },
      { status: 500 }
    );
  }
}

function generateBookFiles(bookConfig: BookConfig): { path: string; content: string }[] {
  const files: { path: string; content: string }[] = [];

  // Generate myst.yml configuration
  files.push({
    path: 'myst.yml',
    content: generateMystConfig(bookConfig),
  });

  // Generate index.md (root page)
  files.push({
    path: 'index.md',
    content: generateIndexPage(bookConfig),
  });

  // Generate chapter files
  const chapterFiles = generateChapterFiles(bookConfig.tableOfContents.chapters);
  files.push(...chapterFiles);

  // Generate GitHub Actions workflow
  files.push({
    path: '.github/workflows/deploy.yml',
    content: generateGitHubWorkflow(),
  });

  // Generate .gitignore
  files.push({
    path: '.gitignore',
    content: generateGitignore(),
  });

  // Generate package.json for npm-based MyST
  files.push({
    path: 'package.json',
    content: generatePackageJson(bookConfig),
  });

  return files;
}

function generateMystConfig(bookConfig: BookConfig): string {
  const enabledFeatures = bookConfig.features.filter((f) => f.enabled);
  const hasJupyter = enabledFeatures.some((f) => f.id === 'jupyter-execution' || f.id === 'binder');

  const config: Record<string, unknown> = {
    version: 1,
    project: {
      title: bookConfig.title,
      description: bookConfig.description,
      authors: [{ name: bookConfig.author }],
      github: bookConfig.github
        ? `https://github.com/${bookConfig.github.username}/${bookConfig.github.repoName}`
        : undefined,
      toc: generateTocConfig(bookConfig.tableOfContents.chapters),
    },
    site: {
      template: 'book-theme',
      title: bookConfig.title,
      options: {
        favicon: '/favicon.ico',
        logo: '/logo.png',
      },
    },
  };

  // Add jupyter configuration if enabled
  if (hasJupyter) {
    const jupyterFeature = enabledFeatures.find((f) => f.id === 'jupyter-execution');
    const binderFeature = enabledFeatures.find((f) => f.id === 'binder');

    if (jupyterFeature) {
      (config.project as Record<string, unknown>).jupyter = { lite: true };
    } else if (binderFeature) {
      (config.project as Record<string, unknown>).jupyter = { binder: true };
    }
  }

  // BASE_URL is handled by the GitHub Actions workflow via environment variable
  // See: https://mystmd.org/guide/deployment-github-pages

  return `# Liquid Books Configuration
# Created by Dr. Lee

version: 1

project:
  title: "${bookConfig.title}"
${bookConfig.description ? `  description: "${bookConfig.description}"` : ''}
  authors:
    - name: "${bookConfig.author}"
${bookConfig.github ? `  github: https://github.com/${bookConfig.github.username}/${bookConfig.github.repoName}` : ''}
${hasJupyter ? `  jupyter:
    lite: true` : ''}
  toc:
${generateTocYaml(bookConfig.tableOfContents.chapters, 4)}

site:
  template: book-theme
  title: "${bookConfig.title}"
${bookConfig.coverImage ? `  options:
    logo: "${bookConfig.coverImage}"` : ''}
`;
}

function generateTocConfig(chapters: Chapter[]): { file: string; children?: unknown[] }[] {
  return chapters.map((chapter) => {
    const entry: { file: string; children?: unknown[] } = {
      file: `${chapter.slug}.md`,
    };
    if (chapter.children && chapter.children.length > 0) {
      entry.children = generateTocConfig(chapter.children);
    }
    return entry;
  });
}

function generateTocYaml(chapters: Chapter[], indent: number, isTopLevel = true): string {
  const spaces = ' '.repeat(indent);

  // MyST rule: First TOC item cannot have children
  // So we flatten any children of the first item into top-level entries
  if (isTopLevel && chapters.length > 0) {
    const result: string[] = [];

    chapters.forEach((chapter, index) => {
      if (index === 0 && chapter.children && chapter.children.length > 0) {
        // First item with children: add it without children, then add its children as top-level
        result.push(`${spaces}- file: ${chapter.slug}.md`);
        // Add children as top-level entries (they can have their own children)
        chapter.children.forEach((child) => {
          let entry = `${spaces}- file: ${child.slug}.md`;
          if (child.children && child.children.length > 0) {
            entry += `\n${spaces}  children:\n${generateTocYaml(child.children, indent + 4, false)}`;
          }
          result.push(entry);
        });
      } else {
        // Other items: normal behavior
        let entry = `${spaces}- file: ${chapter.slug}.md`;
        if (chapter.children && chapter.children.length > 0) {
          entry += `\n${spaces}  children:\n${generateTocYaml(chapter.children, indent + 4, false)}`;
        }
        result.push(entry);
      }
    });

    return result.join('\n');
  }

  // Non-top-level: normal recursive behavior
  return chapters
    .map((chapter) => {
      let entry = `${spaces}- file: ${chapter.slug}.md`;
      if (chapter.children && chapter.children.length > 0) {
        entry += `\n${spaces}  children:\n${generateTocYaml(chapter.children, indent + 4, false)}`;
      }
      return entry;
    })
    .join('\n');
}

function generateIndexPage(bookConfig: BookConfig): string {
  const coverImageSection = bookConfig.coverImage
    ? `
::::{grid} 1 1 2 2
:gutter: 3

:::{grid-item}
:columns: 12 12 4 4

![Book Cover](${bookConfig.coverImage})
:::

:::{grid-item}
:columns: 12 12 8 8

${bookConfig.description}

**Author:** ${bookConfig.author}
:::
::::
`
    : `${bookConfig.description}

## About This Book

Written by ${bookConfig.author}`;

  return `---
title: ${bookConfig.title}
${bookConfig.coverImage ? `thumbnail: ${bookConfig.coverImage}` : ''}
---

# ${bookConfig.title}

${coverImageSection}

## Table of Contents

${bookConfig.tableOfContents.chapters
  .map((ch) => `- [${ch.title}](${ch.slug}.md)${ch.description ? ` - ${ch.description}` : ''}`)
  .join('\n')}

---

*Created with Liquid Books by Dr. Lee*
`;
}

function generateChapterFiles(
  chapters: Chapter[],
  prefix = '',
  isTopLevel = true
): { path: string; content: string }[] {
  const files: { path: string; content: string }[] = [];

  for (let i = 0; i < chapters.length; i++) {
    const chapter = chapters[i];
    const filePath = prefix ? `${prefix}/${chapter.slug}.md` : `${chapter.slug}.md`;

    files.push({
      path: filePath,
      content: generateChapterContent(chapter),
    });

    if (chapter.children && chapter.children.length > 0) {
      // MyST rule: First TOC item cannot have children
      // So first chapter's children go at root level (no prefix)
      if (isTopLevel && i === 0) {
        // First chapter's children: put at root level to match flattened TOC
        files.push(...generateChapterFiles(chapter.children, '', false));
      } else {
        // Other chapters: children go in subdirectory
        files.push(...generateChapterFiles(chapter.children, chapter.slug, false));
      }
    }
  }

  return files;
}

function generateChapterContent(chapter: Chapter): string {
  const content = chapter.content || generatePlaceholderContent(chapter);

  return `---
title: ${chapter.title}
---

# ${chapter.title}

${chapter.description ? `> ${chapter.description}\n` : ''}

${content}
`;
}

function generatePlaceholderContent(chapter: Chapter): string {
  return `
:::{note}
This chapter is a placeholder. Use the AI-powered chapter editor to generate content.
:::

## Overview

This chapter covers **${chapter.title}**.

${chapter.description || 'Content coming soon...'}

## Key Topics

- Topic 1
- Topic 2
- Topic 3

## Examples

\`\`\`python
# Example code will be added here
print("Hello from ${chapter.title}")
\`\`\`

## Summary

Summary of ${chapter.title} will be added here.

---

*Last updated: ${new Date().toISOString().split('T')[0]}*
`;
}

function generateGitHubWorkflow(): string {
  // Based on official MyST docs: https://mystmd.org/guide/deployment-github-pages
  // BASE_URL uses GitHub's dynamic variable - no hardcoding needed
  return `# Liquid Books Deploy
# Created by Dr. Lee
# Based on: https://mystmd.org/guide/deployment-github-pages

name: Liquid Books Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  # BASE_URL determines the website is served from, including CSS & JS assets
  # Uses GitHub's dynamic variable to get the repository name
  BASE_URL: /\${{ github.event.repository.name }}

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: 'pages'
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: \${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Pages
        uses: actions/configure-pages@v3

      - uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Install MyST Markdown
        run: npm install -g mystmd

      - name: Build HTML Assets
        run: myst build --html

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './_build/html'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
`;
}

function generateGitignore(): string {
  return `# Build outputs
_build/
.myst/

# Dependencies
node_modules/

# Environment
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
`;
}

function generatePackageJson(bookConfig: BookConfig): string {
  return JSON.stringify(
    {
      name: bookConfig.github?.repoName || 'my-book',
      version: '1.0.0',
      description: bookConfig.description,
      scripts: {
        start: 'myst start',
        build: 'myst build --html',
        clean: 'myst clean --all',
      },
      keywords: ['liquid-books', 'myst', 'jupyter-book', 'documentation'],
      author: bookConfig.author,
      license: 'MIT',
      devDependencies: {
        mystmd: '^1.0.0',
      },
    },
    null,
    2
  );
}
