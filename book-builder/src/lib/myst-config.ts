/**
 * Shared MyST configuration generation utilities
 */

import { BookConfig, Chapter, BookLevelFeature } from '@/types';
import { BOOK_LEVEL_FEATURES } from '@/data/bookLevelFeatures';

export function generateMystConfig(bookConfig: BookConfig): string {
  const enabledFeatures = bookConfig.features.filter((f) => f.enabled);
  const hasJupyter = enabledFeatures.some((f) => f.id === 'jupyter-execution' || f.id === 'binder');

  // Get book-level features (use defaults if not set)
  const bookFeatures = bookConfig.bookFeatures || BOOK_LEVEL_FEATURES;
  const enabledBookFeatures = bookFeatures.filter((f: BookLevelFeature) => f.enabled);

  // Build site options from book-level features
  const siteOptions: Record<string, unknown> = {
    style: 'styles.css',
  };
  const exportOptions: Record<string, unknown> = {};
  const jupyterOptions: Record<string, unknown> = {};

  // Process enabled book features
  for (const feature of enabledBookFeatures) {
    if (!feature.configKey) continue;

    const parts = feature.configKey.split('.');
    const value = feature.configValue;

    if (parts[0] === 'site' && parts[1] === 'options' && parts[2]) {
      siteOptions[parts[2]] = value;
    } else if (parts[0] === 'export' && parts[1]) {
      exportOptions[parts[1]] = value;
    } else if (parts[0] === 'jupyter' && parts[1]) {
      jupyterOptions[parts[1]] = value;
    }
  }

  // Generate site options YAML
  const generateOptionsYaml = (options: Record<string, unknown>, indent: number): string => {
    const spaces = ' '.repeat(indent);
    const lines: string[] = [];
    for (const [key, value] of Object.entries(options)) {
      if (typeof value === 'boolean') {
        lines.push(`${spaces}${key}: ${value}`);
      } else if (typeof value === 'object' && value !== null) {
        lines.push(`${spaces}${key}:`);
        for (const [subKey, subValue] of Object.entries(value as Record<string, unknown>)) {
          lines.push(`${spaces}  ${subKey}: ${subValue}`);
        }
      } else {
        lines.push(`${spaces}${key}: ${value}`);
      }
    }
    return lines.join('\n');
  };

  // Build options section
  let optionsSection = '';
  if (Object.keys(siteOptions).length > 0 || bookConfig.coverImage) {
    optionsSection = `  options:\n`;
    if (bookConfig.coverImage) {
      optionsSection += `    logo: "${bookConfig.coverImage}"\n`;
    }
    if (Object.keys(siteOptions).length > 0) {
      optionsSection += generateOptionsYaml(siteOptions, 4) + '\n';
    }
  }

  // Build export section
  let exportSection = '';
  if (Object.keys(exportOptions).length > 0) {
    exportSection = `\nexport:\n`;
    for (const [key, value] of Object.entries(exportOptions)) {
      if (typeof value === 'object' && value !== null && (value as Record<string, unknown>).enabled) {
        exportSection += `  ${key}: true\n`;
      }
    }
  }

  // Build jupyter section
  const jupyterConfig = new Map<string, boolean>();
  if (hasJupyter) {
    jupyterConfig.set('lite', true);
  }
  for (const [key, value] of Object.entries(jupyterOptions)) {
    if (typeof value === 'object' && value !== null && (value as Record<string, unknown>).enabled) {
      jupyterConfig.set(key, true);
    } else if (typeof value === 'boolean' && value) {
      jupyterConfig.set(key, true);
    }
  }

  let jupyterSection = '';
  if (jupyterConfig.size > 0) {
    jupyterSection = `  jupyter:\n`;
    for (const [key, value] of jupyterConfig) {
      jupyterSection += `    ${key}: ${value}\n`;
    }
  }

  const enabledFeaturesList = enabledBookFeatures.length > 0
    ? enabledBookFeatures.map((f: BookLevelFeature) => f.name).join(', ')
    : 'none';

  return `# Liquid Books Configuration
# Generated by Liquid Books (https://liquid-books.netlify.app)
# Book-level features (${enabledBookFeatures.length}): ${enabledFeaturesList}

version: 1

project:
  title: "${bookConfig.title}"
${bookConfig.description ? `  description: "${bookConfig.description}"` : ''}
  authors:
    - name: "${bookConfig.author}"
${bookConfig.github ? `  github: https://github.com/${bookConfig.github.username}/${bookConfig.github.repoName}` : ''}
${jupyterSection ? jupyterSection : ''}  toc:
${generateTocYaml(bookConfig.tableOfContents.chapters, 4)}

site:
  template: book-theme
  title: "${bookConfig.title}"
${bookConfig.github ? `  base: /${bookConfig.github.repoName}` : ''}
  logo:
    text: "${bookConfig.title}"
  nav:
    - title: "${bookConfig.title}"
      url: .
${optionsSection}  actions:
    - title: "${bookConfig.title}"
      url: .
  parts:
    footer: footer.md
${exportSection}`;
}

export function generateTocYaml(chapters: Chapter[], indent: number, isTopLevel = true): string {
  const spaces = ' '.repeat(indent);

  if (isTopLevel && chapters.length > 0) {
    const result: string[] = [];

    chapters.forEach((chapter, index) => {
      if (index === 0 && chapter.children && chapter.children.length > 0) {
        result.push(`${spaces}- file: ${chapter.slug}.md`);
        chapter.children.forEach((child) => {
          let entry = `${spaces}- file: ${child.slug}.md`;
          if (child.children && child.children.length > 0) {
            entry += `\n${spaces}  children:\n${generateTocYaml(child.children, indent + 4, false)}`;
          }
          result.push(entry);
        });
      } else {
        let entry = `${spaces}- file: ${chapter.slug}.md`;
        if (chapter.children && chapter.children.length > 0) {
          entry += `\n${spaces}  children:\n${generateTocYaml(chapter.children, indent + 4, false)}`;
        }
        result.push(entry);
      }
    });

    return result.join('\n');
  }

  return chapters
    .map((chapter) => {
      let entry = `${spaces}- file: ${chapter.slug}.md`;
      if (chapter.children && chapter.children.length > 0) {
        entry += `\n${spaces}  children:\n${generateTocYaml(chapter.children, indent + 4, false)}`;
      }
      return entry;
    })
    .join('\n');
}
