import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { BookConfig, Chapter, BookLevelFeature } from '@/types';
import { BOOK_LEVEL_FEATURES } from '@/data/bookLevelFeatures';

interface CreateRepoRequest {
  token: string;
  repoName: string;
  bookConfig: BookConfig;
}

export async function POST(request: NextRequest) {
  try {
    const body: CreateRepoRequest = await request.json();
    const { token: providedToken, repoName, bookConfig } = body;

    // Use provided token or fall back to environment variable
    const token = providedToken || process.env.GITHUB_PAT;

    if (!token || !repoName || !bookConfig) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    const octokit = new Octokit({ auth: token });

    // Get authenticated user
    const { data: user } = await octokit.users.getAuthenticated();
    console.log('Authenticated as:', user.login, '- Type:', user.type);

    // Sanitize description for GitHub (max 350 chars, no control characters)
    const sanitizeDescription = (desc: string | undefined): string => {
      if (!desc) return '';
      // Remove control characters (newlines, tabs, etc.) and trim
      const cleaned = desc.replace(/[\x00-\x1F\x7F]/g, ' ').replace(/\s+/g, ' ').trim();
      // Truncate to 350 characters
      return cleaned.length > 350 ? cleaned.substring(0, 347) + '...' : cleaned;
    };

    const sanitizedDescription = sanitizeDescription(bookConfig.description);

    // Generate book files
    const files = generateBookFiles(bookConfig);

    // Check if repository already exists
    let repoUrl: string;
    let repoExists = false;

    try {
      const { data: existingRepo } = await octokit.repos.get({
        owner: user.login,
        repo: repoName,
      });
      repoExists = true;
      repoUrl = existingRepo.html_url;
      console.log(`Repository ${repoName} exists, updating...`);
    } catch (e: unknown) {
      const error = e as { status?: number };
      if (error.status !== 404) {
        throw e; // Re-throw if not a 404
      }
      // 404 means repo doesn't exist - we'll create it
    }

    if (repoExists) {
      // UPDATE EXISTING REPO - Push new commit with updated files
      // This avoids the delete+create pattern that triggers abuse detection

      // Get the current HEAD commit on main branch
      const { data: ref } = await octokit.git.getRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
      });
      const baseCommitSha = ref.object.sha;

      // Create a new tree with all files (replaces entire content)
      // Using base_tree: undefined creates a completely new tree (clean slate)
      const { data: tree } = await octokit.git.createTree({
        owner: user.login,
        repo: repoName,
        tree: files.map((file) => ({
          path: file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          content: file.content,
        })),
      });

      // Create a commit with parent
      const { data: commit } = await octokit.git.createCommit({
        owner: user.login,
        repo: repoName,
        message: 'Update book content - Generated by Book Builder',
        tree: tree.sha,
        parents: [baseCommitSha],
      });

      // Update the main branch to point to the new commit
      await octokit.git.updateRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
        sha: commit.sha,
      });

      console.log(`Repository ${repoName} updated with new content`);

    } else {
      // CREATE NEW REPO
      // Check if user is an organization or regular user
      const isOrganization = user.type === 'Organization';
      console.log(`Creating repo for ${isOrganization ? 'organization' : 'user'}: ${user.login}`);

      let repo;
      if (isOrganization) {
        // Create repo in organization
        const response = await octokit.repos.createInOrg({
          org: user.login,
          name: repoName,
          description: sanitizedDescription,
          auto_init: true,
          visibility: 'public',
        });
        repo = response.data;
      } else {
        // Create repo for authenticated user
        const response = await octokit.repos.createForAuthenticatedUser({
          name: repoName,
          description: sanitizedDescription,
          auto_init: true,
          private: false,
        });
        repo = response.data;
      }
      repoUrl = repo.html_url;

      // Wait for GitHub to initialize the repository
      await new Promise(resolve => setTimeout(resolve, 1500));

      // Get the SHA of the initial commit on main branch
      const { data: ref } = await octokit.git.getRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
      });
      const baseCommitSha = ref.object.sha;

      // Get the base tree SHA
      const { data: baseCommit } = await octokit.git.getCommit({
        owner: user.login,
        repo: repoName,
        commit_sha: baseCommitSha,
      });
      const baseTreeSha = baseCommit.tree.sha;

      // Create all files in a single commit using Git Data API
      const { data: tree } = await octokit.git.createTree({
        owner: user.login,
        repo: repoName,
        base_tree: baseTreeSha,
        tree: files.map((file) => ({
          path: file.path,
          mode: '100644' as const,
          type: 'blob' as const,
          content: file.content,
        })),
      });

      // Create a commit with parent
      const { data: commit } = await octokit.git.createCommit({
        owner: user.login,
        repo: repoName,
        message: 'Initial book setup - Generated by Book Builder',
        tree: tree.sha,
        parents: [baseCommitSha],
      });

      // Update the main branch to point to the new commit
      await octokit.git.updateRef({
        owner: user.login,
        repo: repoName,
        ref: 'heads/main',
        sha: commit.sha,
      });

      console.log(`Repository ${repoName} created with initial content`);
    }

    // Enable GitHub Pages with GitHub Actions workflow
    // Do this ONCE - no retries to save API calls
    // The workflow will trigger automatically on push anyway
    try {
      await octokit.request('POST /repos/{owner}/{repo}/pages', {
        owner: user.login,
        repo: repoName,
        build_type: 'workflow',
        headers: {
          'X-GitHub-Api-Version': '2022-11-28'
        }
      });
      console.log('GitHub Pages enabled');
    } catch (pagesError: unknown) {
      const err = pagesError as { status?: number };
      // 409 = already exists, 422 = validation error - both are fine
      // The push already happened so the workflow will trigger
      console.log('Pages setup status:', err.status);
    }

    return NextResponse.json({
      success: true,
      repoUrl: repoUrl!,
      username: user.login,
      deployedUrl: `https://${user.login}.github.io/${repoName}`,
    });
  } catch (error: unknown) {
    console.error('GitHub API error:', error);

    // Handle rate limiting specifically
    const err = error as { status?: number; message?: string; response?: { headers?: Record<string, string> } };

    if (err.status === 403 && err.message?.includes('rate limit')) {
      // Try to get reset time from headers
      const resetTime = err.response?.headers?.['x-ratelimit-reset'];
      let waitMessage = 'Please wait a few minutes before trying again.';

      if (resetTime) {
        const resetDate = new Date(parseInt(resetTime) * 1000);
        const minutesUntilReset = Math.ceil((resetDate.getTime() - Date.now()) / 60000);
        waitMessage = `Rate limit resets in ${minutesUntilReset} minute${minutesUntilReset !== 1 ? 's' : ''}.`;
      }

      return NextResponse.json(
        {
          error: `GitHub API rate limit exceeded. ${waitMessage}`,
          isRateLimit: true,
          retryAfter: resetTime ? parseInt(resetTime) * 1000 : Date.now() + 60000,
        },
        { status: 429 }
      );
    }

    // Handle other specific errors
    if (err.status === 401) {
      return NextResponse.json(
        { error: 'GitHub token is invalid or expired. Please check your Personal Access Token.' },
        { status: 401 }
      );
    }

    if (err.status === 422) {
      // Extract actual GitHub error message for better debugging
      const githubMessage = (error as { message?: string }).message || 'Unknown validation error';
      console.error('GitHub 422 error details:', githubMessage);

      // Check for common issues
      let userMessage = 'Invalid repository name or configuration.';
      if (githubMessage.includes('name already exists')) {
        userMessage = 'A repository with this name already exists. Please choose a different name.';
      } else if (githubMessage.includes('organization')) {
        userMessage = 'Cannot create repository in organization. Please use a personal access token from a personal account.';
      } else {
        userMessage = `GitHub error: ${githubMessage}`;
      }

      return NextResponse.json(
        { error: userMessage },
        { status: 422 }
      );
    }

    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'GitHub API failed' },
      { status: 500 }
    );
  }
}

function generateBookFiles(bookConfig: BookConfig): { path: string; content: string }[] {
  const files: { path: string; content: string }[] = [];

  // Generate myst.yml configuration
  files.push({
    path: 'myst.yml',
    content: generateMystConfig(bookConfig),
  });

  // Generate index.md (root page)
  files.push({
    path: 'index.md',
    content: generateIndexPage(bookConfig),
  });

  // Generate chapter files
  const chapterFiles = generateChapterFiles(bookConfig.tableOfContents.chapters);
  files.push(...chapterFiles);

  // Generate GitHub Actions workflow
  files.push({
    path: '.github/workflows/deploy.yml',
    content: generateGitHubWorkflow(),
  });

  // Generate .gitignore
  files.push({
    path: '.gitignore',
    content: generateGitignore(),
  });

  // Generate package.json for npm-based MyST
  files.push({
    path: 'package.json',
    content: generatePackageJson(bookConfig),
  });

  // Generate custom footer for Liquid Books branding
  files.push({
    path: 'footer.md',
    content: generateFooter(),
  });

  return files;
}

function generateMystConfig(bookConfig: BookConfig): string {
  const enabledFeatures = bookConfig.features.filter((f) => f.enabled);
  const hasJupyter = enabledFeatures.some((f) => f.id === 'jupyter-execution' || f.id === 'binder');

  // Get book-level features (use defaults if not set)
  const bookFeatures = bookConfig.bookFeatures || BOOK_LEVEL_FEATURES;
  const enabledBookFeatures = bookFeatures.filter((f: BookLevelFeature) => f.enabled);

  // Build site options from book-level features
  // Always hide MyST branding and use Liquid Books branding
  const siteOptions: Record<string, unknown> = {
    hide_myst_branding: true,
  };
  const exportOptions: Record<string, unknown> = {};
  const jupyterOptions: Record<string, unknown> = {};

  // Process enabled book features
  for (const feature of enabledBookFeatures) {
    if (!feature.configKey) continue;

    const parts = feature.configKey.split('.');
    const value = feature.configValue;

    // Route to appropriate options object based on configKey prefix
    if (parts[0] === 'site' && parts[1] === 'options' && parts[2]) {
      siteOptions[parts[2]] = value;
    } else if (parts[0] === 'export' && parts[1]) {
      exportOptions[parts[1]] = value;
    } else if (parts[0] === 'jupyter' && parts[1]) {
      jupyterOptions[parts[1]] = value;
    }
  }

  // Generate site options YAML
  const generateOptionsYaml = (options: Record<string, unknown>, indent: number): string => {
    const spaces = ' '.repeat(indent);
    const lines: string[] = [];
    for (const [key, value] of Object.entries(options)) {
      if (typeof value === 'boolean') {
        lines.push(`${spaces}${key}: ${value}`);
      } else if (typeof value === 'object' && value !== null) {
        lines.push(`${spaces}${key}:`);
        for (const [subKey, subValue] of Object.entries(value as Record<string, unknown>)) {
          lines.push(`${spaces}  ${subKey}: ${subValue}`);
        }
      } else {
        lines.push(`${spaces}${key}: ${value}`);
      }
    }
    return lines.join('\n');
  };

  // Build options section
  let optionsSection = '';
  if (Object.keys(siteOptions).length > 0 || bookConfig.coverImage) {
    optionsSection = `  options:\n`;
    if (bookConfig.coverImage) {
      optionsSection += `    logo: "${bookConfig.coverImage}"\n`;
    }
    if (Object.keys(siteOptions).length > 0) {
      optionsSection += generateOptionsYaml(siteOptions, 4) + '\n';
    }
  }

  // Build export section
  let exportSection = '';
  if (Object.keys(exportOptions).length > 0) {
    exportSection = `\nexport:\n`;
    for (const [key, value] of Object.entries(exportOptions)) {
      if (typeof value === 'object' && value !== null && (value as Record<string, unknown>).enabled) {
        exportSection += `  ${key}: true\n`;
      }
    }
  }

  // Build jupyter section - collect all enabled jupyter options into a single object to prevent duplicates
  // Use a Map to ensure unique keys
  const jupyterConfig = new Map<string, boolean>();

  // Add from hasJupyter flag (chapter-level jupyter features)
  if (hasJupyter) {
    jupyterConfig.set('lite', true);
  }

  // Add from book-level features (will overwrite if key exists)
  for (const [key, value] of Object.entries(jupyterOptions)) {
    if (typeof value === 'object' && value !== null && (value as Record<string, unknown>).enabled) {
      jupyterConfig.set(key, true);
    } else if (typeof value === 'boolean' && value) {
      jupyterConfig.set(key, true);
    }
  }

  let jupyterSection = '';
  if (jupyterConfig.size > 0) {
    jupyterSection = `  jupyter:\n`;
    for (const [key, value] of jupyterConfig) {
      jupyterSection += `    ${key}: ${value}\n`;
    }
  }

  // Detailed logging for book-level features
  console.log('=== BOOK-LEVEL FEATURES CONFIGURATION ===');
  console.log(`Total book features: ${bookFeatures.length}, Enabled: ${enabledBookFeatures.length}`);
  if (enabledBookFeatures.length > 0) {
    console.log('Enabled book-level features:');
    for (const f of enabledBookFeatures) {
      console.log(`  - ${f.id} (${f.name}): configKey=${f.configKey || 'none'}, category=${f.category}`);
    }
  }
  console.log('Site options:', JSON.stringify(siteOptions, null, 2));
  console.log('Export options:', JSON.stringify(exportOptions, null, 2));
  console.log('Jupyter config:', Array.from(jupyterConfig.entries()));
  console.log('==========================================');

  // Build a comment listing enabled features for visibility in the generated file
  const enabledFeaturesList = enabledBookFeatures.length > 0
    ? enabledBookFeatures.map((f: BookLevelFeature) => f.name).join(', ')
    : 'none';

  return `# Liquid Books Configuration
# Generated by Liquid Books (https://liquid-books.netlify.app)
# Book-level features (${enabledBookFeatures.length}): ${enabledFeaturesList}

version: 1

project:
  title: "${bookConfig.title}"
${bookConfig.description ? `  description: "${bookConfig.description}"` : ''}
  authors:
    - name: "${bookConfig.author}"
${bookConfig.github ? `  github: https://github.com/${bookConfig.github.username}/${bookConfig.github.repoName}` : ''}
${jupyterSection ? jupyterSection : ''}  toc:
${generateTocYaml(bookConfig.tableOfContents.chapters, 4)}

site:
  template: book-theme
  title: "${bookConfig.title}"
${optionsSection}  parts:
    footer: footer.md
${exportSection}`;
}

function generateTocConfig(chapters: Chapter[]): { file: string; children?: unknown[] }[] {
  return chapters.map((chapter) => {
    const entry: { file: string; children?: unknown[] } = {
      file: `${chapter.slug}.md`,
    };
    if (chapter.children && chapter.children.length > 0) {
      entry.children = generateTocConfig(chapter.children);
    }
    return entry;
  });
}

function generateTocYaml(chapters: Chapter[], indent: number, isTopLevel = true): string {
  const spaces = ' '.repeat(indent);

  // MyST rule: First TOC item cannot have children
  // So we flatten any children of the first item into top-level entries
  if (isTopLevel && chapters.length > 0) {
    const result: string[] = [];

    chapters.forEach((chapter, index) => {
      if (index === 0 && chapter.children && chapter.children.length > 0) {
        // First item with children: add it without children, then add its children as top-level
        result.push(`${spaces}- file: ${chapter.slug}.md`);
        // Add children as top-level entries (they can have their own children)
        chapter.children.forEach((child) => {
          let entry = `${spaces}- file: ${child.slug}.md`;
          if (child.children && child.children.length > 0) {
            entry += `\n${spaces}  children:\n${generateTocYaml(child.children, indent + 4, false)}`;
          }
          result.push(entry);
        });
      } else {
        // Other items: normal behavior
        let entry = `${spaces}- file: ${chapter.slug}.md`;
        if (chapter.children && chapter.children.length > 0) {
          entry += `\n${spaces}  children:\n${generateTocYaml(chapter.children, indent + 4, false)}`;
        }
        result.push(entry);
      }
    });

    return result.join('\n');
  }

  // Non-top-level: normal recursive behavior
  return chapters
    .map((chapter) => {
      let entry = `${spaces}- file: ${chapter.slug}.md`;
      if (chapter.children && chapter.children.length > 0) {
        entry += `\n${spaces}  children:\n${generateTocYaml(chapter.children, indent + 4, false)}`;
      }
      return entry;
    })
    .join('\n');
}

function generateIndexPage(bookConfig: BookConfig): string {
  const coverImageSection = bookConfig.coverImage
    ? `
::::{grid} 1 1 2 2
:gutter: 3

:::{grid-item}
:columns: 12 12 4 4

![Book Cover](${bookConfig.coverImage})
:::

:::{grid-item}
:columns: 12 12 8 8

${bookConfig.description}

**Author:** ${bookConfig.author}
:::
::::
`
    : `${bookConfig.description}

## About This Book

Written by ${bookConfig.author}`;

  return `---
title: ${bookConfig.title}
${bookConfig.coverImage ? `thumbnail: ${bookConfig.coverImage}` : ''}
---

# ${bookConfig.title}

${coverImageSection}

## Table of Contents

${bookConfig.tableOfContents.chapters
  .map((ch) => `- [${ch.title}](${ch.slug}.md)${ch.description ? ` - ${ch.description}` : ''}`)
  .join('\n')}

---

*Created with Liquid Books by Dr. Lee*
`;
}

function generateChapterFiles(
  chapters: Chapter[],
  prefix = '',
  isTopLevel = true
): { path: string; content: string }[] {
  const files: { path: string; content: string }[] = [];

  for (let i = 0; i < chapters.length; i++) {
    const chapter = chapters[i];
    const filePath = prefix ? `${prefix}/${chapter.slug}.md` : `${chapter.slug}.md`;

    files.push({
      path: filePath,
      content: generateChapterContent(chapter),
    });

    if (chapter.children && chapter.children.length > 0) {
      // MyST rule: First TOC item cannot have children
      // So first chapter's children go at root level (no prefix)
      if (isTopLevel && i === 0) {
        // First chapter's children: put at root level to match flattened TOC
        files.push(...generateChapterFiles(chapter.children, '', false));
      } else {
        // Other chapters: children go in subdirectory
        files.push(...generateChapterFiles(chapter.children, chapter.slug, false));
      }
    }
  }

  return files;
}

function generateChapterContent(chapter: Chapter): string {
  const content = chapter.content || generatePlaceholderContent(chapter);

  return `---
title: ${chapter.title}
---

# ${chapter.title}

${chapter.description ? `> ${chapter.description}\n` : ''}

${content}
`;
}

function generatePlaceholderContent(chapter: Chapter): string {
  return `
:::{note}
This chapter is a placeholder. Use the AI-powered chapter editor to generate content.
:::

## Overview

This chapter covers **${chapter.title}**.

${chapter.description || 'Content coming soon...'}

## Key Topics

- Topic 1
- Topic 2
- Topic 3

## Examples

\`\`\`python
# Example code will be added here
print("Hello from ${chapter.title}")
\`\`\`

## Summary

Summary of ${chapter.title} will be added here.

---

*Last updated: ${new Date().toISOString().split('T')[0]}*
`;
}

function generateGitHubWorkflow(): string {
  // Based on official MyST docs: https://mystmd.org/guide/deployment-github-pages
  // BASE_URL uses GitHub's dynamic variable - no hardcoding needed
  return `# Liquid Books Deploy
# Created by Dr. Lee
# Based on: https://mystmd.org/guide/deployment-github-pages

name: Liquid Books Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  # BASE_URL determines the website is served from, including CSS & JS assets
  # Uses GitHub's dynamic variable to get the repository name
  BASE_URL: /\${{ github.event.repository.name }}

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: 'pages'
  cancel-in-progress: false

jobs:
  deploy:
    environment:
      name: github-pages
      url: \${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Pages
        uses: actions/configure-pages@v3

      - uses: actions/setup-node@v4
        with:
          node-version: 18.x

      - name: Install MyST Markdown
        run: npm install -g mystmd

      - name: Build HTML Assets
        run: myst build --html

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './_build/html'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
`;
}

function generateGitignore(): string {
  return `# Build outputs
_build/
.myst/

# Dependencies
node_modules/

# Environment
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
`;
}

function generatePackageJson(bookConfig: BookConfig): string {
  return JSON.stringify(
    {
      name: bookConfig.github?.repoName || 'my-book',
      version: '1.0.0',
      description: bookConfig.description,
      scripts: {
        start: 'myst start',
        build: 'myst build --html',
        clean: 'myst clean --all',
      },
      keywords: ['liquid-books', 'myst', 'jupyter-book', 'documentation'],
      author: bookConfig.author,
      license: 'MIT',
      devDependencies: {
        mystmd: '^1.0.0',
      },
    },
    null,
    2
  );
}

function generateFooter(): string {
  return `::::{div}
:class: footer-branding

:::{image} https://liquid-books.netlify.app/liquid-books-logo.png
:alt: Liquid Books
:height: 24px
:class: footer-logo
:::

**Created with [Liquid Books](https://liquid-books.netlify.app) by Dr. Lee**

::::
`;
}
